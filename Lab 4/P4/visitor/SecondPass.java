//
// Generated by JTB 1.3.2
//

package visitor;
import syntaxtree.*;
import visitor.External.FunctionInfo;
import visitor.External.TempInfo;

import java.util.*;

/**
 * Provides default methods which visit each node in the tree in depth-first
 * order.  Your visitors may extend this class.
 */
public class SecondPass<R,A> implements GJVisitor<R,A> {
   //
   // Auto class visitors--probably don't need to be overridden.
   //
   public External ext;
   Integer blockCount = 0;
   External.FunctionInfo curFunction;
   External.BlockInfo curBlock;
   String funcName = null;
   Integer SP = 0;
   Integer LabelCount = 0;
   Boolean LabelisFuncName = true;
   HashMap<String, String> labelMapping = new HashMap<String, String>();
   Integer ParamCount = 0;

   void PrintFuncName(FunctionInfo f)
   {
        System.out.println(f.name + " [" + f.numArgs +"] [" + f.StackSpace + "] [" + f.maxArgs +"]");
        System.out.flush();
        return;
   }
   
   void SpilledOrNay(FunctionInfo f)
   {
        if(f.TempStackMap.size()>0)
        {
            System.out.println("// SPILLED");
            System.out.flush();
        }
        else
        {
            System.out.println("// NOTSPILLED");
            System.out.flush();
        }
   }
   
   void CalleeSave(FunctionInfo f)
   {
      int begin = SP;
      for(int i=0; i<8; i++)
      {
         System.out.println("\tASTORE SPILLEDARG " + SP + " s"+i);
         System.out.flush();
         SP++;
      }
      return;
   }
   
   void CalleeLoad(Integer begin)
   {
        for(int i=0; i<8; i++)
        {
            System.out.println("\tALOAD s"+ i + " SPILLEDARG " + begin);
            System.out.flush();
            begin++;
        }
   }
   
   void CallerSave(FunctionInfo f)
   {
      for(int i=0; i<10; i++)
      {
         System.out.println("\tASTORE SPILLEDARG " + SP + " t"+ i);
         System.out.flush();
         SP++;
      }
      return;
   }

   void CallerLoad(Integer begin)
   {
        for(int i=0; i<10; i++)
        {
            System.out.println("\tALOAD t"+ i + " SPILLEDARG " + begin);
            System.out.flush();
            begin++;
        }
   }

   String fetchTemp(FunctionInfo f, Integer tempNum, String reg)
   {
      if(!f.temps.containsKey(tempNum))
      {
         return "v1";
      }
      External.TempInfo t = f.temps.get(tempNum);
      if(t.start > blockCount || t.end < blockCount)
      {
         return "v1";
      }
      if(f.TempStackMap.containsKey(t))
      {
         Integer Offset = f.TempStackMap.get(t);
         if(f.numArgs>4)
         {
            Offset += f.numArgs-4;
         }
         System.out.println("\tALOAD " + reg + " SPILLEDARG "+ Offset);
         System.out.flush();
         return reg;
      }
      else if(f.TempRegMap.containsKey(t))
      {
         reg = f.TempRegMap.get(t);
         return reg;
      }
      return "v1";
   }

   void MoveExp(String tempNum, String exp, FunctionInfo f)
   {
      Integer tnum = Integer.parseInt(tempNum);
      if(!(f.temps.containsKey(tnum))) {
         System.out.println("\tMOVE v1 " + exp);
         System.out.flush();
      }
      else if(f.temps.get(tnum).start > blockCount || f.temps.get(tnum).end < blockCount)
      {
         System.out.println("\tMOVE v1 " + exp);
         System.out.flush();
      }
      else if(f.TempStackMap.containsKey(f.temps.get(tnum)))
      {
         System.out.println("\tMOVE v0 " + exp);
         System.out.flush();
         Integer Offset = f.TempStackMap.get(f.temps.get(tnum));
         if(f.numArgs>4)
         {
            Offset += f.numArgs-4;
         }
         System.out.println("\tASTORE SPILLEDARG " + Offset +" v0");
         System.out.flush();
      }
      else if(f.TempRegMap.containsKey(f.temps.get(tnum)))
      {
         System.out.println("\tMOVE " + f.TempRegMap.get(f.temps.get(tnum)) + " " + exp);
         System.out.flush();
      }
   }

   void storeArgs(FunctionInfo f)
   {
      if(f.numArgs < 4)
      {
         for(int i=0; i< f.numArgs; i++)
         {
            MoveExp(Integer.toString(i), "a"+i, f);
         }
         return;
      }
      for(int i=0; i<4; i++)
      {
         MoveExp(Integer.toString(i), "a"+i, f);
      }
      for(int i=4; i<f.numArgs; i++)
      {
         System.out.println("\tALOAD v0 SPILLEDARG " + (i-4));
         System.out.flush();
         MoveExp(Integer.toString(i), "v0", f);
      }
   }

   public R visit(NodeList n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeListOptional n, A argu) {
      if ( n.present() ) {
         R _ret=null;
         int _count=0;
         for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
            e.nextElement().accept(this,argu);
            _count++;
         }
         return _ret;
      }
      else
         return null;
   }

   public R visit(NodeOptional n, A argu) {
      if ( n.present() )
         return n.node.accept(this,argu);
      else
         return null;
   }

   public R visit(NodeSequence n, A argu) {
      R _ret=null;
      int _count=0;
      for ( Enumeration<Node> e = n.elements(); e.hasMoreElements(); ) {
         e.nextElement().accept(this,argu);
         _count++;
      }
      return _ret;
   }

   public R visit(NodeToken n, A argu) { return null; }

   //
   // User-generated visitor methods below
   //

   /**
    * f0 -> "MAIN"
    * f1 -> StmtList()
    * f2 -> "END"
    * f3 -> ( Procedure() )*
    * f4 -> <EOF>
    */
   public R visit(Goal n, A argu) {
      R _ret=null;
      funcName = "MAIN";
      curFunction = ext.SymbolTable.get(funcName);
      SP = curFunction.sp;
      n.f0.accept(this, argu);
      PrintFuncName(curFunction);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      System.out.println("END");
      System.out.flush();
      SpilledOrNay(curFunction);
      n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> ( ( Label() )? Stmt() )*
    */
   public R visit(StmtList n, A argu) {
      R _ret=null;
      LabelisFuncName = false;
      n.f0.accept(this, (A)"y");
      LabelisFuncName = true;
      return _ret;
   }

   /**
    * f0 -> Label()
    * f1 -> "["
    * f2 -> IntegerLiteral()
    * f3 -> "]"
    * f4 -> StmtExp()
    */
   public R visit(Procedure n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f3.accept(this, argu);
      blockCount = 0;
      funcName = n.f0.f0.tokenImage;
      curFunction = ext.SymbolTable.get(funcName);
      PrintFuncName(curFunction);
      Integer begin = curFunction.sp;
      SP = curFunction.sp;
      CalleeSave(curFunction);
      storeArgs(curFunction);
      n.f4.accept(this, argu);
      CalleeLoad(begin);
      System.out.println("END");
      System.out.flush();
      SpilledOrNay(curFunction);
      return _ret;
   }

   /**
    * f0 -> NoOpStmt()
    *       | ErrorStmt()
    *       | CJumpStmt()
    *       | JumpStmt()
    *       | HStoreStmt()
    *       | HLoadStmt()
    *       | MoveStmt()
    *       | PrintStmt()
    */
   public R visit(Stmt n, A argu) {
      R _ret=null;
      argu = null;
      LabelisFuncName = true;
      n.f0.accept(this, null);
      LabelisFuncName = false;
      blockCount++;
      return _ret;
   }

   /**
    * f0 -> "NOOP"
    */
   public R visit(NoOpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      System.out.println("\tNOOP");
      System.out.flush();
      return _ret;
   }

   /**
    * f0 -> "ERROR"
    */
   public R visit(ErrorStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      System.out.println("\tERROR");
      System.out.flush();
      return _ret;
   }

   /**
    * f0 -> "CJUMP"
    * f1 -> Temp()
    * f2 -> Label()
    */
   public R visit(CJumpStmt n, A argu) {
      R _ret=null;
      String t=null, label = null;
      n.f0.accept(this, argu);
      Integer arg = -2;
      t = (String) n.f1.accept(this, (A)arg);
      label = (String) n.f2.accept(this, (A)"y");
      System.out.println("\tCJUMP " + t + " " + label + "__" + curFunction.name);
      System.out.println("\tNOOP");
      System.out.flush();
      return _ret;
   }

   /**
    * f0 -> "JUMP"
    * f1 -> Label()
    */
   public R visit(JumpStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String label = null;
      label = (String)n.f1.accept(this, (A)"y");
      System.out.println("\tJUMP " + label + "__" + curFunction.name);
      System.out.println("\tNOOP");
      System.out.flush();
      return _ret;
   }

   /**
    * f0 -> "HSTORE"
    * f1 -> Temp()
    * f2 -> IntegerLiteral()
    * f3 -> Temp()
    */
   public R visit(HStoreStmt n, A argu) {
      R _ret=null;
      String t1 = null, t2 = null, t3 = null;
      n.f0.accept(this, argu);
      Integer arg1 = -2, arg2 = -3;
      t1 = (String)n.f1.accept(this, (A)arg1);
      t2 = (String)n.f2.accept(this, argu);
      t3 = (String)n.f3.accept(this, (A)arg2);
      System.out.println("\tHSTORE " + t1 + " " + t2 + " " + t3);
      System.out.flush();
      return _ret;
   }

   /**
    * f0 -> "HLOAD"
    * f1 -> Temp()
    * f2 -> Temp()
    * f3 -> IntegerLiteral()
    */
   public R visit(HLoadStmt n, A argu) {
      R _ret=null;
      String t1 = null, t2 = null, t3 = null;
      n.f0.accept(this, argu);
      Integer arg1 = -1, arg2 = -2;
      t1 = (String)n.f1.accept(this, (A)arg1);
      t2 = (String)n.f2.accept(this, (A)arg2);
      t3 = (String)n.f3.accept(this, argu);
      System.out.println("\tHLOAD " + "v0" + " " + t2 + " " + t3);
      System.out.flush();
      MoveExp(t1, "v0", curFunction);
      return _ret;
   }

   /**
    * f0 -> "MOVE"
    * f1 -> Temp()
    * f2 -> Exp()
    */
   public R visit(MoveStmt n, A argu) {
      R _ret=null;
      String tempNum = null, exp = null;
      n.f0.accept(this, argu);
      Integer arg = -1;
      tempNum = (String)n.f1.accept(this, (A)arg);
      exp = (String)n.f2.accept(this, argu);
      MoveExp(tempNum, exp, curFunction);
      return _ret;
   }

   /**
    * f0 -> "PRINT"
    * f1 -> SimpleExp()
    */
   public R visit(PrintStmt n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String retVal = (String)n.f1.accept(this, null);
      System.out.println("\tPRINT " + retVal);
      System.out.flush();
      return _ret;
   }

   /**
    * f0 -> Call()
    *       | HAllocate()
    *       | BinOp()
    *       | SimpleExp()
    */
   public R visit(Exp n, A argu) {
      R _ret=null;
      _ret = (R)n.f0.accept(this, argu);
      return _ret;
   }

   /**
    * f0 -> "BEGIN"
    * f1 -> StmtList()
    * f2 -> "RETURN"
    * f3 -> SimpleExp()
    * f4 -> "END"
    */
   public R visit(StmtExp n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      String retVal = (String) n.f3.accept(this, argu);
      n.f4.accept(this, argu);
      System.out.println("\tMOVE v0 " + retVal);
      System.out.flush();
      LabelisFuncName = true;
      return _ret;
   }

   /**
    * f0 -> "CALL"
    * f1 -> SimpleExp()
    * f2 -> "("
    * f3 -> ( Temp() )*
    * f4 -> ")"
    */
   public R visit(Call n, A argu) {
      R _ret=null;
      String reg = null;
      Integer arg = 0;
      ParamCount = 0;
      n.f3.accept(this, (A)arg);
      n.f0.accept(this, argu);
      Integer begin = SP;
      reg = (String)n.f1.accept(this, argu);
      n.f2.accept(this, argu);
      n.f4.accept(this, argu);
      CallerSave(curFunction);
      System.out.println("\tCALL " + reg);
      System.out.flush();
      CallerLoad(begin);
      SP = begin;
      _ret = (R)"v0";
      return _ret;
   }

   /**
    * f0 -> "HALLOCATE"
    * f1 -> SimpleExp()
    */
   public R visit(HAllocate n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      String se = (String)n.f1.accept(this, null);
      _ret = (R)("HALLOCATE " + se);
      return _ret;
   }

   /**
    * f0 -> Operator()
    * f1 -> Temp()
    * f2 -> SimpleExp()
    */
   public R visit(BinOp n, A argu) {
      R _ret=null;
      String operator = null, temp1 = null, temp2 = null;
      Integer arg1 = -3;
      operator = (String)n.f0.accept(this, argu);
      temp1 = (String)n.f1.accept(this, (A)arg1);
      temp2 = (String)n.f2.accept(this, argu);
      _ret = (R)(operator + " " + temp1 + " " + temp2);
      return _ret;
   }

   /**
    * f0 -> "LE"
    *       | "NE"
    *       | "PLUS"
    *       | "MINUS"
    *       | "TIMES"
    *       | "DIV"
    */
   public R visit(Operator n, A argu) {
      R _ret=null;
      String op = null;
      if(n.f0.which==0)
      {
         op = "LE";
      }
      else if(n.f0.which==1)
      {
         op = "NE";
      }
      else if(n.f0.which==2)
      {
         op = "PLUS";
      }
      else if(n.f0.which==3)
      {
         op = "MINUS";
      }
      else if(n.f0.which==4)
      {
         op = "TIMES";
      }
      else if(n.f0.which==5)
      {
         op = "DIV";
      }
      n.f0.accept(this, argu);
      _ret = (R) op;
      return _ret;
   }

   /**
    * f0 -> Temp()
    *       | IntegerLiteral()
    *       | Label()
    */
   public R visit(SimpleExp n, A argu) {
      R _ret=null;
      Integer arg = -2;
      LabelisFuncName = true;
      _ret = (R) n.f0.accept(this, (A)arg);
      LabelisFuncName = false;
      return _ret;
   }

   /**
    * f0 -> "TEMP"
    * f1 -> IntegerLiteral()
    */
   public R visit(Temp n, A argu) {
      R _ret=null;
      String tempNum = null, reg = null;
      n.f0.accept(this, argu);
      tempNum = (String)n.f1.accept(this, argu);
      Integer arg = (Integer)argu;
      if(arg.equals(-1))
      {
         _ret = (R)tempNum;
         return _ret;
      }
      if(arg.equals(-2))
      {
         reg = "v0";
         Integer intTempNum = Integer.parseInt(tempNum);
         reg = fetchTemp(curFunction, intTempNum, reg);  
      }
      if(arg.equals(-3))
      {
         reg = "v1";
         Integer intTempNum = Integer.parseInt(tempNum);
         reg = fetchTemp(curFunction, intTempNum, reg);
      }
      if(arg>=0)
      {
         reg = "v0";
         Integer intTempNum = Integer.parseInt(tempNum);
         reg = fetchTemp(curFunction, intTempNum, reg); 
         Integer argumentCount = arg;
         if(ParamCount<4)
         {
            System.out.println("\tMOVE a"+ParamCount+" "+reg);
            System.out.flush();
         }
         else
         {
            System.out.println("\tPASSARG " + (ParamCount-3) + " " + reg);
            System.out.flush();
         }
         ParamCount++;
      }
      _ret = (R)reg;
      return _ret;
   }

   /**
    * f0 -> <INTEGER_LITERAL>
    */
   public R visit(IntegerLiteral n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      _ret = (R)(n.f0.tokenImage);
      return _ret;
   }

   /**
    * f0 -> <IDENTIFIER>
    */
   public R visit(Label n, A argu) {
      R _ret=null;
      n.f0.accept(this, argu);
      if(!LabelisFuncName)
      {
         System.out.println(n.f0.tokenImage + "__" + curFunction.name);
         System.out.println("\tNOOP");
      }
      _ret = (R)(n.f0.tokenImage);
      return _ret;
   }

}

